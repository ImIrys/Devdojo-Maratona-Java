Aula 20: Estruturas Condicionais - Parte 1:

-> IF <-
- IF = SE
- Só executa se a expressão/resultado da expressão dentro do parênteses for VERDADEIRO/TRUE
- Sintaxe:
    if (true) {
    System.out.println("Dentro do if");
    }
- O resultado ou o que colocar dentro desses parênteses precisa ser um BOOLEANO
-Exemplo 1: Saber se o usuário pode ou não comprar bebida alcoólica:
        int idade = 15;

        if (idade >= 18) {
            System.out.println("Usuário maior de idade. Permitido comprar bebida alcoólica.");
        }
        else {
            System.out.println("Usuário menor de idade. Não é permitido a venda de bebidas alcoólicas para menores de idade.");
        }

- Tbm é possível fazer a comparação da seguinte maneira:
    - O valor booleano será alocado em memória na isAutorizadoComprarBebida
        boolean isAutorizadoComprarBebida = idade >= 18;
        if (isAutorizadoComprarBebida) {
            System.out.println("Usuário maior de idade. Permitido comprar bebida alcoólica.");
        } else {
            System.out.println("Usuário menor de idade. Não é permitido a venda de bebidas alcoólicas para menores de idade.");
        }

*Operador de negação*
- Existe uma opção alternativa ao uso do ELSE:
- Essa opção sempre fará a análise.
    - Se não isAutorizadoComprarBebida então imprima Não autorizado a comprar bebida alcoólica.
        boolean isAutorizadoComprarBebida = idade >= 18;
           if (!isAutorizadoComprarBebida){ //O mesmo que escrever isAutorizadoComprarBebida == false
            System.out.println("Não autorizado a comprar bebida alcoólica.");

======================================================================================================================================================

Aula 21: Estruturas Condicionais - Parte 2: ELSE IF

-> ELSE <-
- ELSE = se não;
- Precisa estar dentro do seu IF;
- Executado automaticamente baseado na condição dentro do IF;
- Instrução independente, será executado independente do IF ser verdadeiro ou não;

---Quando se tem mais de 2 condições---

*Exemplo: Definir a categoria de futebol.*
-Jogadores menores de 15 anos são da categoria infantil;
-Jogadores entre 15 e 18, fazem parte da categoria juvenil;
-Jogadores maiores de 18, fazem parte da categoria adulto.


int idade = 16;

        if (idade < 15) {
            System.out.println("Categoria Infantil");
        } else if (idade >= 16 && idade < 18) {
            System.out.println("Categoria Juvenil");
        } else {
            System.out.println("Categoria Adulto");
        }

- Tbm pode ser feito da seguinte maneira:

int idade = 16;
String = categoria;
        if (idade < 15) {
            categoria = "Categoria Infantil";
        } else if (idade >= 16 && idade < 18) {
            categoria = "Categoria Juvenil";
        } else {
            categoria = "Categoria Adulto";
        }

    System.out.println(categoria);

----Escopos dentro do JAVA----

- Baseado onde tem o bloco de código entre as chaves;
*ESCOPO LOCAL*
- Todas as variáveis que estão num bloco que não é o bloco da classe (fora de qualquer método), que estão dentro de métodos;
- Todas as variáveis de Escopo Local - VARIÁVEIS LOCAIS - precisam ser inicializadas antes que tente executá-las.

======================================================================================================================================================

22 - Estruturas Condicionais pt 03 - Operador ternário

- Criado no JAVA para simplificar condições IF-ELSE;

*EXERCÍCIO*
// Decidir se farei uma doação de R$ 500,00*
- Salário acima de R$ 5.000,00 = farei a doação de R$ 500,00.
- Exibir a mensagem fazer doação ou não.

// Doar se salário > 5000
        double salario = 3000;
        String mensagemDoar = "Vou conseguir doar 500,00";
        String mensagemNaoDoar = "Não posso doar nada.";
        String resultado;

        if (salario > 5000) {
            resultado = mensagemDoar;
        } else {
            resultado = mensagemNaoDoar;
        }
        System.out.println(resultado);

- Estamos criando um IF-ELSE para guardar um valor dentro de uma variável;
- Quando se tem esse caso em especifico podemos usare o OPERADOR TERNÁRIO.

----Operador Ternário----
- Deve ser usado em situações de IF-ELSE simples;
- Precisa pegar um resultado e colocar num lugar;
- Sempre vai associar um valor diretamente para uma variável ou retorno de um método;
- Sintaxe: dividido em 3 partes: (condicao) ? verdadeiro : falso;
EXEMPLO:
        // Doar se salário > 5000
        double salario = 6000;
        String mensagemDoar = "Vou conseguir doar 500,00";
        String mensagemNaoDoar = "Não posso doar nada.";
        // (condicao) ? verdadeiro : falso;
        String resultado = salario > 5000 ? mensagemDoar : mensagemNaoDoar;

        System.out.println(resultado);
    }

- Tbm podemos simplificar mais ainda o código:

// Doar se salário > 5000
        double salario = 6000;
        // (condicao) ? verdadeiro : falso;
        String resultado = salario > 5000 ? "Vou conseguir doar 500,00" : "Não posso doar nada.";

        System.out.println(resultado);
    }

======================================================================================================================================================

23 - Estruturas Condicionais pt 04 - Tabela Verdade e exercício

----Tabela Verdade----
- Define o que teremos coo resultado de uma expressão booleana quando se tem mais de uma condição.
-- E/AND &&
- TODAS as instruções que temos no IF precisam ser verdadeiras para que o resultado final seja verdadeiro.

-- OU/OR ||
- Se UMA das instruções que temos no IF for verdadeira, o resultado será verdadeiro.

*EXERCÍCIO*
// Dado um determinado salário anual, calcule o valor do imposto a ser pago.

        double salarioAnual = 70000;
        double primeiraFaixa = 9.70 / 100;
        double segundaFaixa = 37.35 / 100;
        double terceiraFaixa = 49.50 / 100;
        double valorImposto;

        if (salarioAnual <= 34712){
            valorImposto = salarioAnual * primeiraFaixa;
        } else if (salarioAnual >= 34713 && salarioAnual <= 68507) {
            valorImposto = salarioAnual * segundaFaixa;
        } else {
            valorImposto = salarioAnual * terceiraFaixa;
        }

        System.out.println(valorImposto);

======================================================================================================================================================

25 - Estruturas Condicionais pt 06 - Switch

---- SWITCH ----
- Forma mais organizada de utilizar CONDICIONAIS SIMPLES para fazer uma pequena escolha.
- Sintaxe do SWITCH:
// valores dentro do switch - tipos de variáveis: char, int, byte, short, enum, String.

switch (dia){
    case 1:
        System.out.println("Domingo");
        break;
    case 2:
        System.out.println("Segunda");
        break;
    case 3:
        System.out.println("Terça");
        break;
    case 4:
        System.out.println("Quarta");
        break;
    case 5:
        System.out.println("Quinta");
        break;
    case 6:
        System.out.println("Sexta");
        break;
    case 7:
        System.out.println("Sábado");
        break;

- Uso da opção padrão: default
default:
        System.out.println("Opção Inválida");
        break;

======================================================================================================================================================

27 - Estruturas de Repetição pt 01 - Laços de repetição while, do while, for

- Estruturas de repetição precisam da informação ATÉ QUANDO/QUANTO precisa ficar contando, executando em repetição.
- Usa-se uma condição
- Existem 3 opções para iterar sobre alguma coisa:
1) While
- SINTAXE:

while(){
}

// O resultado dentro da expressão precisa ser um valor booleano, assim como no IF.
// A expressão precisa ser de COMPARAÇÃO
// A expressão precisa ser verdadeira para o while ser executado
// O estado da variável precisa ser alterado dentro do escopo do WHILE, para não ficar num loop infinit

*Exemplo*
 int count = 0;
 while (count < 10){
     System.out.println(count);
     count += 1; // count = count + 1;

2) Do While
- A expressão será executada pelo menos 1 vez, independente da condição ser TRUE ou FALSE;
- Usa-se uma condição
- SINTAXE:
do {
// o que quero que seja feito
} while

*Exemplo:*

int count = 0;
do {
    System.out.println(count);
} while (count < 10)

3) For
- Mais utilizado para contagens;
- Usa-se índices, enquanto no WHILE se usa condição.

- SINTAXE:
// na primeira parte declaração de variáveis (variável local precisa ser inicializada antes de ser utilizada)
// na segunda parte se faz a comparação até onde o laço de repetição seja executado,
// na terceira parte, como essa variável vai alterar o status.

for (int i=0; i < 10; i++) {
     System.out.println("For " +i);
}

-- int i=0 será executado apenas 1 vez;
-- i < 10 será executado todas as vezes em que o laço estiver sendo executado;
-- i++ vai incrementar 1 em todas as vezes que i < 10 for falso.

======================================================================================================================================================

31 - Estruturas de Repetição pt 05 - Continue

-

======================================================================================================================================================

VETORES

32 - Arrays - Parte 01

-São considerados objetos na memória;
-Quando temos que trabalhar com determinada quantidade valores, relacionado ao mesmo tipo de variável.
-Arrays (vetores) funcionam como referência um espaço de memória que pode ter mais de um valor
-Tipo de variavel usada para declarar é um tipo reference. Podem ser iniciadas com valor nulo;
-Sintaxe:
tipo[] nome;
tipo nome[];

Ao criar ARRAYS Temos:
Variável do lado esquerdo é do tipo REFERENCE: Variavel do lado direito é um OBJETO
int[] idades = new int[3];


- A variável por ser reference pode ser iniciada com null, assim como a variável do tipo String.
- O indice sempre começa de 0 e vai até a posição desejada.

idades[0] = 31;
idades[1] = 32;
idades[2] = 30;

=============================================================================

33 - Arrays - Parte 02

Padrão de inicialização de tipos primitivos:
byte, short, int, long, float e double o valor é 0.
char tem o unicode que representa um espaço em branco '\u0000' ' '
boolean padrão é false
String padrão é null


=============================================================================

34 - Arrays - Parte 03 - Como iterar e pegar os valores dentro do arrays.

- O tamanho do Array não muda dinamicamente, temos que alterá-lo na forma manual e compilar o programa novamente.]

=============================================================================

35 - Arrays pt 04 - Foreach
- Formas de iniciar os Arrays:

1ª Forma de iniciar um array temos que declará-lo
int[] numeros = new int[3];

2ª Forma de iniciar os arrays com o tamanho e diretamente os valores:
int[] numeros2 = {1,2,3,4,5};

3ª Forma de iniciar um array:
int[] numeros3 = new int[]{1,2,3,4,5};

- Formas de imprimir o Arrays:
1ª Forma: Usando o FOR
for (int i = 0; i < numeros3.length; i++) {
            System.out.println(numeros3[i]);
        }

2ª Forma: Usando o Foreach
Esse FOR não dá para acessar índices específicos;
Sintaxe: dizer o tipo do array.
for(int num:numeros3){
System.out.println(num);
}

=============================================================================

36 e 37 - Arrays Multidimensionais pt 01 e pt 02

- São Arrays de arrays.
- Arrays linkados e com isso navegar pelas posições que eles possuem.

Para criar arrays multidimensionais:
        int[][] dias = new int[3][3];


Usando o foreach para imprimir array multidimensioanl:
- Pega cada uma das posições que temos e cria uma variável de referência

=============================================================================

38 - Arrays Multidimensionais pt 01

Inicialização de Arrays:

1ª Forma:
arrayInt[1] = new int[]{1,2,3};

2ª Forma:
Criar um array com os valores que desejo e depois faezr referência a ele:
public static void main(String[] args) {
        int[] array = {1,2,3};

        arrayInt[1] = array;

3ª Forma:
int[][] arrayInt2 = {{0,0},{1,2,3},{1,2,3,4,5,6}};

=============================================================================

39 - Orientação Objetos pt 01 - Introdução classes pt 01

*Variáveis do tipo primitivo:*
--Não possuem relação entre si.

*Variáveis do tipo objeto (reference):*
--Objeto--
-Diferentes dados agrupados dentro de um único espaço em memória.
-Possuem um vínculo, um relacionamento entre eles.
-Para criar objetos sempre usar a palavra new seguido do nome do objeto a ser criado.
-Exemplo:
/Variável de referência do tipo estudante.
/Para criar objetos sempre usar a palavra new.
Estudante estudante = new Estudante();


--Classe--
-Representa algo do mundo real com funcionalidades em comum, que dá origem ao objeto.
-Podem ter um public static void main, mas não será utilizado aqui.
-Chamadas de domínio, algo que representa um mapeamento no mundo real, não possuem método main.
-É um Template que dará origem a um objeto. Podem ter 2 coisas: Atributos = características da classe (nome, idade e sexo). Métodos = comportamentos.

Exemplo:
Classe Carro -> Atributos: marca, modelo, ano de fabricação.
Classe Funcionario -> salario, matricula, cpf.

=============================================================================

40 - Orientação Objetos pt 02 - Introdução classes pt 02

- Quando se cria um atributo diretamente numa classe, os valores de inicialização serão o padrão aplicados a ele.
Podemos utilizar mesmo que não tenha sido inicializado.
Exemplo: public class Estudante {
             public String nome; // Posso definir,inicializar diretamente, mas em todos os objetos, em 'nome' receberão o mesmo valor.
             public int idade;
             public char sexo;

=============================================================================

41 - Orientação Objetos - Coesão

- Coesão: Relacionado ao propósito das classes.
- Não misturar o propósito de suas existências.
- 1 propósito por classe.

Exemplo 1:
public class Estudante {
    public String nome = "Flicka";
    public int idade;
    public char sexo;

 public String nomeProfessor;
    public int idadeProfessor;
    public char sexoProfessor;

OBS: Técnicamente, esse código não está errado, mas no proprósito de manutenção, está errado.
Pois, está se tratando de 2 coisas numa classe específica.
Criar uma própria classe para Professor.

Exemplo 2: Colocar o public static void main
public class Estudante {
    public String nome = "Flicka";
    public int idade;
    public char sexo;

public static void main (String[] args) {
    }
}

OBS: O código está fazendo 2 coisas:
1º) A classe Estudante, está representando o domínio estudante no mundo real
2º) Está representando a execução desse estudante

Ao criar uma classe específica para teste, deixamos o código coeso.

=============================================================================

42 - Orientação Objetos - Exercício Classes

Criar uma classe carro com os seguintes atributos

Nome
Modelo
ano

Em seguida, criar dois objetos distintos e imprima seus valores.

public static void main(String[] args) {
        Carro carro1 = new Carro();
        Carro carro2 = new Carro();

        carro1.nome = "Nissan March";
        carro1.modelo = "SV 1.6";
        carro1.ano = 2024;

        carro2.nome = "Jeep Renegade";
        carro2.modelo = "1.3 Turbo";
        carro2.ano = 2024;

        System.out.println("===================  1ª OPÇÃO: ===================");
        System.out.println(carro1.nome + ", " +carro1.modelo + ", " +carro1.ano);
        System.out.println("\n===================  2ª OPÇÃO: ===================");
        System.out.println(carro2.nome + ", " +carro2.modelo + ", " +carro2.ano);

=============================================================================

43 - Orientação Objetos - Referência de objetos

Variáveis de referência podem referenciar outros objetos, é associado a um objeto no momento de sua criação e posteriormente pode ser trocada.

        Carro carro1 = new Carro();
        Carro carro2 = new Carro();

        carro1.nome = "Nissan March";
        carro1.modelo = "SV 1.6";
        carro1.ano = 2024;

        carro2.nome = "Jeep Renegade";
        carro2.modelo = "1.3 Turbo";
        carro2.ano = 2024;

// OBS: No momento em que se executa a linha de código abaixo, a referência do espaço de memória anterior se perde.
        carro1 = carro2;

=============================================================================

44 - Orientação Objetos - Métodos pt 01

--Atributos--
-SINTAXE: modificador de acesso + tipo da variável + identificador
-Exemplo1: public int idade;
-Exemplo2: professor.nome = "Kakashi";
-OBS: Usa-se o sinal de igual para dar o valor.

--Métodos--
-SINTAXE: modificador de acesso + retorno + nome do método + () + {}
-Parecido com os atributos mas com a funcionalidade diferente;
-Refere-se ao comportamento das classes;
-Eles retornam algo ou não retorna nada. (Diferente de saída)
-Exemplo1: public void somaDoisNumeros(){}
-Exemplo2: calculadora.somaDoisNumeros();
-OBS: Usa-se o ponto final + o nome do método seguido de parentêses

**Assim como os Atributos, os métodos são executados nos objetos.

=============================================================================

45 - Orientação Objetos - Métodos pt 02 - Parâmetros

--Parâmetros--
-SINTAXE: tipo de variável + identificador
(os tipos primitivos ou as de referência, até mesmo arrays)
-São variáveis locais.
-Exemplo: public void multiplicaDoisNumeros(int num1, int num2)

=============================================================================

46 - Orientação Objetos - Métodos pt 03 - Retorno pt 01

Método com retorno
REGRA: Também pode ser usado para métodos void.

public + tipo da variável primitiva ou reference + nome da variável {
return x;
}

=============================================================================

47 - Orientação Objetos - Métodos pt 04 - Retorno pt 02

1)Outra forma de usar o Return:
public double divideDoisNumeros02(double num1, double num2){
        if (num1 == 0 || num2 == 0) {
            return 0;
        } else
        return num1/num2;
    }

2)Outra forma:
public double divideDoisNumeros02(double num1, double num2){
         if (num2 != 0) {
         return num1/num2;
         }
         return 0;

3) Usando o return no método void:
public void imprimeDivisaoDoisNumeros(double num1, double num2) {
        if (num2 == 0) {
            System.out.println("Não existe divisão por zero.");
        }
        System.out.println(num1/num2);

OBS: Usar uma chamada de método dentro de um system.out.println em que o retorno é void (não existe), terá um erro de compilação.
O system.out.println precisa de um valor para imprimir no console.
Então, para executar o método, é preciso retirar o system.out.println

System.out.println(calculadora.imprimeDivisaoDoisNumeros(20,10));

calculadora.imprimeDivisaoDoisNumeros(20,10);

3.1)Usando o return:
public void imprimeDivisaoDoisNumeros(double num1, double num2) {
        if (num2 == 0) {
            System.out.println("Não existe divisão por zero.");
            return;
        }
            System.out.println(num1 / num2);

---------------
- Usando o if else
public void imprimeDivisaoDoisNumeros(double num1, double num2) {
        if (num2 == 0) {
            System.out.println("Não existe divisão por zero.");
        } else {
            System.out.println(num1 / num2);

=============================================================================

48 - Orientação Objetos - Métodos pt 05 - Parâmetros tipo primitivo

-Passagem de parâmetros do tipo primitivo:
Quando se passa valores do tipo primitivo para um método não estamos passando a referência daquele objeto em memória, estamos fazendo uma cópia.
*Então, passando variáveis do tipo primitivo, sempre envia-se uma cópia.
-A variável original nunca será alterada dentro do método.

=============================================================================

49 - Orientação Objetos - Métodos pt 06 - Parâmetros tipo referência

-Passagem de parâmetros do tipo referência:
Quando passamos parâmetros via referência estamos passando a própria referência dele.
Quando passamos objetos como argumento, na verdade estamos passando a referência aonde aquele objeto está guardado.
A referência original continua.

-Com 2 objetos, como melhorar o código sem a necessidade de repetição em que apenas a variável de referutilizando a coesão:
Criar uma variável através de uma classe específica.

=============================================================================

50 - Orientação Objetos - Métodos pt 07 - Parâmetros tipo referência pt 02

-Quando se altera algo dentro do objeto, essa alteração é mantida para as outras referências que ainda possuem ligação com esse objeto.
-Qualquer alteração feito dentro da classe vai afetar o objeto que esteja contido nela.
-OBS: A passagem de parâmetro via referência é perigosa, pois quando usamos tipos primitivos usa-se uma cópia (nunca altera-se o original),
mas passagem de parametros via referência, tudo o que for feito no objeto, afetará o objeto, independente do que fizermos dentro de outra classe ou dentro da classse originária (onde criou-se o objeto)
-As boas regras da programação diz que ao invés de alterar os dados que estão sendo passado para o objeto, é preciso retornar um novo objeto.

=============================================================================

51 - Orientação Objetos - Métodos pt 08 - Referência this

-Toda vez que executamos alguma coisa temos que chamar a variável de referência.
-Quem executa os dado em si é o objeto.
-Atribuir um valor: variavel de referencia.atributo = alguma coisa
-Estamos sempre executando dentro do método.

Método imprime
-Quando fica dentro do objeto, ao ser chamado, consehue acessar todos os valores que tem disponivel,
isso ajuda a não precisar criar uma variável de referência. Na prórpia variável de referência só chamaremos o atributo imprime.

THIS:
-Palavra reservada usada para se referir a algo que está dentro do próprio objeto.
-

A variável de referência é como um controle remoto, e os atributos são os botões desse controle.
O objeto é quem executa.

=============================================================================

52 - Orientação Objetos - Métodos pt 09 - Varargs

Varargs:
- Sintaxe que foi criada para deixar as coisas mais simples.
- Outra forma de representar os Arrays.
- A vantagem dele em comparação aos Arrays é a forma mais simples de passar vários elementos do mesmo tipo para um método.
Sintaxe: tipo + ... + nomedavariavel
public void somaVarArgs(int ... numeros)

-VarArgs precisa vir depois caso haja outro atributo.
public void somaVarArgs(double valor, double v2, int ... numeros)

=============================================================================

53 - Orientação Objetos - Métodos pt 10 - Exercise
-Exercício relacionado a Métodos, Classes, Objetos e tudo o que foi visto até agora:

CRIE UMA CLASSE FUNCIONÁRIO COM OS SEGUINTES ATRIBUTOS:

nome
idade
salario // 3 salários devem ser guardados

CRIE 2 MÉTODOS

1. PARA IMPRIMIR OS DADOS
2. PARA TIRAR A MÉDIA DOS SALÁRIOS E IMPRIMIR O RESULTADO


OBS: Dividir o problema e resolver cada parte.

=============================================================================

54 - Orientação Objetos - Modificador de acesso private, get e set pt 01

//
OBS: Para iniciar um objeto: Temos que criar uma variável de referência,
em seguida instanciar um objeto, e precisamos inicializar os atributos.
//

-Acoplamento: o quanto uma classe conhece da outra.
O quão uma classe está conectada com a outra.
-Para isso, temos os modificadores de acesso (public, private)
-Uma forma de garantir baixo acoplamento é utilizar modificadores de acesso privado.

--PRIVATE--
- Os atributos só poderão ser acessados pelos objetos.
- Pode-se criar o objeto, mas ao executar o método imprime, vai imprimir os valores padrões na criação de variáveis de classe.
- Como atribuir valores:
Quando se criar atributos privados, pode-se criar um método para acessá-los
REGRA DO JAVA:
SEMPRE QUE FOR CRIAR UM MÉTODO PARA INSERIR UM VALOR DENTRO DE UM ATRIBUTO INICIA-SE DIGITANDO A PALAVRA set.

-Como proteger ao usar o set:

OBS:
Alta Coesão é BOM
Baixo Acoplamento é BOM

--SET x GET--
set é para setar (precisa de um argumento do mesmo tipo da variável, não vai retornar nada)
get é para pegar (

=============================================================================

55 - Orientação Objetos - Modificador de acesso private, get e set pt 02

A variável de referência acessa tudo que é público. (set, get)
Exemplo:

private String nome;
private int idade;

setNome(String nome) // esse nome vai para o espaço de memória do private String nome
getNome() // retorna o que tem em memória no private String nome

------

Dentro do objeto, temos acesso a tudo dentro dele, incluindo os métodos.

=============================================================================

56 - Orientação Objetos - Modificador de acesso private, get e set pt 03

Importância de tomar cuidado ao criar um método get, set para um atributo:

*HACKS:
alt+insert = gera os getters e setters

Forma de bloquear o acesso a escrita e deixar somente a leitura
Remover o set (o que dá o valor ao atributo) e deixar somente o get (retorna o que temos em memória)

=============================================================================

57 - Orientação Objetos - Sobrecarga de métodos

Deixar a estrutura do set e get no final do código, pois em termos de importância,
são menores do que o método para impressão e os atributos.

- Sobrecarga de métodos: Ter um método com o mesmo nome,
porém o tipo ou a quantidade dos parâmetros são diferentes.
OBS: o modificador de acesso e o retorno não importam aqui. (public void)

- Criar métodos que peçam vários argumentos:
public void nomedometodo

Para evitar quebra de código, cria-se outro método com o mesmo nome.

PROBLEMA: Repetição de código.
SOLUÇÃO: chamar o primeiro método dentro do segundo método

REGRA DA SOBRECARGA:
-Ter o método com o mesmo nome só que a quantidade de parâmetro ou
o tipo dos parâmetros precisa se diferente.

=============================================================================

58 - Orientação Objetos - Construtores pt 01

- Construtores: Todas as vezes que criamos um objetos estamos construindo um objeto.
- Se não escrevermos um construtor na classe, o JAVA vai adicionar um no meio
da compilação (transformar o .java em .class)
- Precisa-se de um construtor para se dar origem ao um objeto.


1ª REGRA:
Construtor não tem nenhum tipo de retorno.
SINTAXE: modificador de acesso + nome da classe + () {}
EXEMPLO: public Anime(){}

--------------------------
OBS1: Construtor x Método:
Método: tem retorno (void)
public void Anime(){}
Construtor: não tem retorno
public Anime(){}
--------------------------

VANTAGEM DOS CONSTRUTORES:
- Força a seguir algumas regras.
- É executado antes de qualquer método contido na classe.
- Podemos usar o construtor para a inicialização de objetos na criação do mesmo.
- SOBRECARGA DE CONSTRUTORES: Criar objeto com todos os atributos e sem atributos
Criar outro construtor com o mesmo nome, obrigatoriamente, mas cria-se sem os parâmetros.

--------------------------
OBS2:
- É um inicializador dos objetos, responsável pela criação no momento
em que se pede determinados parâmetros é obrigatório passá-los,
a não ser que se tenha um construtor sobrecarregado.
--------------------------

=============================================================================

59 - Orientação Objetos - Construtores pt 02 - Sobrecarga

