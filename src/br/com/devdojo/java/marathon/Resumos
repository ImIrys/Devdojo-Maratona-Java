Aula 20: Estruturas Condicionais - Parte 1:

-> IF <-
- IF = SE
- Só executa se a expressão/resultado da expressão dentro do parênteses for VERDADEIRO/TRUE
- Sintaxe:
    if (true) {
    System.out.println("Dentro do if");
    }
- O resultado ou o que colocar dentro desses parênteses precisa ser um BOOLEANO
-Exemplo 1: Saber se o usuário pode ou não comprar bebida alcoólica:
        int idade = 15;

        if (idade >= 18) {
            System.out.println("Usuário maior de idade. Permitido comprar bebida alcoólica.");
        }
        else {
            System.out.println("Usuário menor de idade. Não é permitido a venda de bebidas alcoólicas para menores de idade.");
        }

- Tbm é possível fazer a comparação da seguinte maneira:
    - O valor booleano será alocado em memória na isAutorizadoComprarBebida
        boolean isAutorizadoComprarBebida = idade >= 18;
        if (isAutorizadoComprarBebida) {
            System.out.println("Usuário maior de idade. Permitido comprar bebida alcoólica.");
        } else {
            System.out.println("Usuário menor de idade. Não é permitido a venda de bebidas alcoólicas para menores de idade.");
        }

*Operador de negação*
- Existe uma opção alternativa ao uso do ELSE:
- Essa opção sempre fará a análise.
    - Se não isAutorizadoComprarBebida então imprima Não autorizado a comprar bebida alcoólica.
        boolean isAutorizadoComprarBebida = idade >= 18;
           if (!isAutorizadoComprarBebida){ //O mesmo que escrever isAutorizadoComprarBebida == false
            System.out.println("Não autorizado a comprar bebida alcoólica.");

======================================================================================================================================================

Aula 21: Estruturas Condicionais - Parte 2: ELSE IF

-> ELSE <-
- ELSE = se não;
- Precisa estar dentro do seu IF;
- Executado automaticamente baseado na condição dentro do IF;
- Instrução independente, será executado independente do IF ser verdadeiro ou não;

---Quando se tem mais de 2 condições---

*Exemplo: Definir a categoria de futebol.*
-Jogadores menores de 15 anos são da categoria infantil;
-Jogadores entre 15 e 18, fazem parte da categoria juvenil;
-Jogadores maiores de 18, fazem parte da categoria adulto.


int idade = 16;

        if (idade < 15) {
            System.out.println("Categoria Infantil");
        } else if (idade >= 16 && idade < 18) {
            System.out.println("Categoria Juvenil");
        } else {
            System.out.println("Categoria Adulto");
        }

- Tbm pode ser feito da seguinte maneira:

int idade = 16;
String = categoria;
        if (idade < 15) {
            categoria = "Categoria Infantil";
        } else if (idade >= 16 && idade < 18) {
            categoria = "Categoria Juvenil";
        } else {
            categoria = "Categoria Adulto";
        }

    System.out.println(categoria);

----Escopos dentro do JAVA----

- Baseado onde tem o bloco de código entre as chaves;
*ESCOPO LOCAL*
- Todas as variáveis que estão num bloco que não é o bloco da classe (fora de qualquer método), que estão dentro de métodos;
- Todas as variáveis de Escopo Local - VARIÁVEIS LOCAIS - precisam ser inicializadas antes que tente executá-las.

======================================================================================================================================================

22 - Estruturas Condicionais pt 03 - Operador ternário

- Criado no JAVA para simplificar condições IF-ELSE;

*EXERCÍCIO*
// Decidir se farei uma doação de R$ 500,00*
- Salário acima de R$ 5.000,00 = farei a doação de R$ 500,00.
- Exibir a mensagem fazer doação ou não.

// Doar se salário > 5000
        double salario = 3000;
        String mensagemDoar = "Vou conseguir doar 500,00";
        String mensagemNaoDoar = "Não posso doar nada.";
        String resultado;

        if (salario > 5000) {
            resultado = mensagemDoar;
        } else {
            resultado = mensagemNaoDoar;
        }
        System.out.println(resultado);

- Estamos criando um IF-ELSE para guardar um valor dentro de uma variável;
- Quando se tem esse caso em especifico podemos usare o OPERADOR TERNÁRIO.

----Operador Ternário----
- Deve ser usado em situações de IF-ELSE simples;
- Precisa pegar um resultado e colocar num lugar;
- Sempre vai associar um valor diretamente para uma variável ou retorno de um método;
- Sintaxe: dividido em 3 partes: (condicao) ? verdadeiro : falso;
EXEMPLO:
        // Doar se salário > 5000
        double salario = 6000;
        String mensagemDoar = "Vou conseguir doar 500,00";
        String mensagemNaoDoar = "Não posso doar nada.";
        // (condicao) ? verdadeiro : falso;
        String resultado = salario > 5000 ? mensagemDoar : mensagemNaoDoar;

        System.out.println(resultado);
    }

- Tbm podemos simplificar mais ainda o código:

// Doar se salário > 5000
        double salario = 6000;
        // (condicao) ? verdadeiro : falso;
        String resultado = salario > 5000 ? "Vou conseguir doar 500,00" : "Não posso doar nada.";

        System.out.println(resultado);
    }

======================================================================================================================================================

23 - Estruturas Condicionais pt 04 - Tabela Verdade e exercício

----Tabela Verdade----
- Define o que teremos coo resultado de uma expressão booleana quando se tem mais de uma condição.
-- E/AND &&
- TODAS as instruções que temos no IF precisam ser verdadeiras para que o resultado final seja verdadeiro.

-- OU/OR ||
- Se UMA das instruções que temos no IF for verdadeira, o resultado será verdadeiro.

*EXERCÍCIO*
// Dado um determinado salário anual, calcule o valor do imposto a ser pago.

        double salarioAnual = 70000;
        double primeiraFaixa = 9.70 / 100;
        double segundaFaixa = 37.35 / 100;
        double terceiraFaixa = 49.50 / 100;
        double valorImposto;

        if (salarioAnual <= 34712){
            valorImposto = salarioAnual * primeiraFaixa;
        } else if (salarioAnual >= 34713 && salarioAnual <= 68507) {
            valorImposto = salarioAnual * segundaFaixa;
        } else {
            valorImposto = salarioAnual * terceiraFaixa;
        }

        System.out.println(valorImposto);

======================================================================================================================================================

25 - Estruturas Condicionais pt 06 - Switch

---- SWITCH ----
- Forma mais organizada de utilizar CONDICIONAIS SIMPLES para fazer uma pequena escolha.
- Sintaxe do SWITCH:
// valores dentro do switch - tipos de variáveis: char, int, byte, short, enum, String.

switch (dia){
    case 1:
        System.out.println("Domingo");
        break;
    case 2:
        System.out.println("Segunda");
        break;
    case 3:
        System.out.println("Terça");
        break;
    case 4:
        System.out.println("Quarta");
        break;
    case 5:
        System.out.println("Quinta");
        break;
    case 6:
        System.out.println("Sexta");
        break;
    case 7:
        System.out.println("Sábado");
        break;

- Uso da opção padrão: default
default:
        System.out.println("Opção Inválida");
        break;

======================================================================================================================================================

27 - Estruturas de Repetição pt 01 - Laços de repetição while, do while, for

- Estruturas de repetição precisam da informação ATÉ QUANDO/QUANTO precisa ficar contando, executando em repetição.
- Usa-se uma condição
- Existem 3 opções para iterar sobre alguma coisa:
1) While
- SINTAXE:

while(){
}

// O resultado dentro da expressão precisa ser um valor booleano, assim como no IF.
// A expressão precisa ser de COMPARAÇÃO
// A expressão precisa ser verdadeira para o while ser executado
// O estado da variável precisa ser alterado dentro do escopo do WHILE, para não ficar num loop infinit

*Exemplo*
 int count = 0;
 while (count < 10){
     System.out.println(count);
     count += 1; // count = count + 1;

2) Do While
- A expressão será executada pelo menos 1 vez, independente da condição ser TRUE ou FALSE;
- Usa-se uma condição
- SINTAXE:
do {
// o que quero que seja feito
} while

*Exemplo:*

int count = 0;
do {
    System.out.println(count);
} while (count < 10)

3) For
- Mais utilizado para contagens;
- Usa-se índices, enquanto no WHILE se usa condição.

- SINTAXE:
// na primeira parte declaração de variáveis (variável local precisa ser inicializada antes de ser utilizada)
// na segunda parte se faz a comparação até onde o laço de repetição seja executado,
// na terceira parte, como essa variável vai alterar o status.

for (int i=0; i < 10; i++) {
     System.out.println("For " +i);
}

-- int i=0 será executado apenas 1 vez;
-- i < 10 será executado todas as vezes em que o laço estiver sendo executado;
-- i++ vai incrementar 1 em todas as vezes que i < 10 for falso.

======================================================================================================================================================

31 - Estruturas de Repetição pt 05 - Continue

-

======================================================================================================================================================

VETORES

32 - Arrays - Parte 01

-São considerados objetos na memória;
-Quando temos que trabalhar com determinada quantidade valores, relacionado ao mesmo tipo de variável.
-Arrays (vetores) funcionam como referência um espaço de memória que pode ter mais de um valor
-Tipo de variavel usada para declarar é um tipo reference. Podem ser iniciadas com valor nulo;
-Sintaxe:
tipo[] nome;
tipo nome[];

Ao criar ARRAYS Temos:
Variável do lado esquerdo é do tipo REFERENCE: Variavel do lado direito é um OBJETO
int[] idades = new int[3];


- A variável por ser reference pode ser iniciada com null, assim como a variável do tipo String.
- O indice sempre começa de 0 e vai até a posição desejada.

idades[0] = 31;
idades[1] = 32;
idades[2] = 30;

=============================================================================

33 - Arrays - Parte 02

Padrão de inicialização de tipos primitivos:
byte, short, int, long, float e double o valor é 0.
char tem o unicode que representa um espaço em branco '\u0000' ' '
boolean padrão é false
String padrão é null


=============================================================================

34 - Arrays - Parte 03 - Como iterar e pegar os valores dentro do arrays.

- O tamanho do Array não muda dinamicamente, temos que alterá-lo na forma manual e compilar o programa novamente.]

=============================================================================

35 - Arrays pt 04 - Foreach
- Formas de iniciar os Arrays:

1ª Forma de iniciar um array temos que declará-lo
int[] numeros = new int[3];

2ª Forma de iniciar os arrays com o tamanho e diretamente os valores:
int[] numeros2 = {1,2,3,4,5};

3ª Forma de iniciar um array:
int[] numeros3 = new int[]{1,2,3,4,5};

- Formas de imprimir o Arrays:
1ª Forma: Usando o FOR
for (int i = 0; i < numeros3.length; i++) {
            System.out.println(numeros3[i]);
        }

2ª Forma: Usando o Foreach
Esse FOR não dá para acessar índices específicos;
Sintaxe: dizer o tipo do array.
for(int num:numeros3){
System.out.println(num);
}

=============================================================================

36 e 37 - Arrays Multidimensionais pt 01 e pt 02

- São Arrays de arrays.
- Arrays linkados e com isso navegar pelas posições que eles possuem.

Para criar arrays multidimensionais:
        int[][] dias = new int[3][3];


Usando o foreach para imprimir array multidimensioanl:
- Pega cada uma das posições que temos e cria uma variável de referência

=============================================================================

38 - Arrays Multidimensionais pt 01

Inicialização de Arrays:

1ª Forma:
arrayInt[1] = new int[]{1,2,3};

2ª Forma:
Criar um array com os valores que desejo e depois faezr referência a ele:
public static void main(String[] args) {
        int[] array = {1,2,3};

        arrayInt[1] = array;

3ª Forma:
int[][] arrayInt2 = {{0,0},{1,2,3},{1,2,3,4,5,6}};

=============================================================================

39 - Orientação Objetos pt 01 - Introdução classes pt 01

*Variáveis do tipo primitivo:*
--Não possuem relação entre si.

*Variáveis do tipo objeto (reference):*
--Objeto--
-Diferentes dados agrupados dentro de um único espaço em memória.
-Possuem um vínculo, um relacionamento entre eles.
-Para criar objetos sempre usar a palavra new seguido do nome do objeto a ser criado.
-Exemplo:
/Variável de referência do tipo estudante.
/Para criar objetos sempre usar a palavra new.
Estudante estudante = new Estudante();


--Classe--
-Representa algo do mundo real com funcionalidades em comum, que dá origem ao objeto.
-Podem ter um public static void main, mas não será utilizado aqui.
-Chamadas de domínio, algo que representa um mapeamento no mundo real, não possuem método main.
-É um Template que dará origem a um objeto. Podem ter 2 coisas: Atributos = características da classe (nome, idade e sexo). Métodos = comportamentos.

Exemplo:
Classe Carro -> Atributos: marca, modelo, ano de fabricação.
Classe Funcionario -> salario, matricula, cpf.

=============================================================================

40 - Orientação Objetos pt 02 - Introdução classes pt 02

- Quando se cria um atributo diretamente numa classe, os valores de inicialização serão o padrão aplicados a ele.
Podemos utilizar mesmo que não tenha sido inicializado.
Exemplo: public class Estudante {
             public String nome; // Posso definir,inicializar diretamente, mas em todos os objetos, em 'nome' receberão o mesmo valor.
             public int idade;
             public char sexo;

=============================================================================

41 - Orientação Objetos - Coesão

- Coesão: Relacionado ao propósito das classes.
- Não misturar o propósito de suas existências.
- 1 propósito por classe.

Exemplo 1:
public class Estudante {
    public String nome = "Flicka";
    public int idade;
    public char sexo;

 public String nomeProfessor;
    public int idadeProfessor;
    public char sexoProfessor;

OBS: Técnicamente, esse código não está errado, mas no proprósito de manutenção, está errado.
Pois, está se tratando de 2 coisas numa classe específica.
Criar uma própria classe para Professor.

Exemplo 2: Colocar o public static void main
public class Estudante {
    public String nome = "Flicka";
    public int idade;
    public char sexo;

public static void main (String[] args) {
    }
}

OBS: O código está fazendo 2 coisas:
1º) A classe Estudante, está representando o domínio estudante no mundo real
2º) Está representando a execução desse estudante

Ao criar uma classe específica para teste, deixamos o código coeso.

=============================================================================

42 - Orientação Objetos - Exercício Classes

Criar uma classe carro com os seguintes atributos

Nome
Modelo
ano

Em seguida, criar dois objetos distintos e imprima seus valores.

public static void main(String[] args) {
        Carro carro1 = new Carro();
        Carro carro2 = new Carro();

        carro1.nome = "Nissan March";
        carro1.modelo = "SV 1.6";
        carro1.ano = 2024;

        carro2.nome = "Jeep Renegade";
        carro2.modelo = "1.3 Turbo";
        carro2.ano = 2024;

        System.out.println("===================  1ª OPÇÃO: ===================");
        System.out.println(carro1.nome + ", " +carro1.modelo + ", " +carro1.ano);
        System.out.println("\n===================  2ª OPÇÃO: ===================");
        System.out.println(carro2.nome + ", " +carro2.modelo + ", " +carro2.ano);

=============================================================================

43 - Orientação Objetos - Referência de objetos

Variáveis de referência podem referenciar outros objetos, é associado a um objeto no momento de sua criação e posteriormente pode ser trocada.

        Carro carro1 = new Carro();
        Carro carro2 = new Carro();

        carro1.nome = "Nissan March";
        carro1.modelo = "SV 1.6";
        carro1.ano = 2024;

        carro2.nome = "Jeep Renegade";
        carro2.modelo = "1.3 Turbo";
        carro2.ano = 2024;

// OBS: No momento em que se executa a linha de código abaixo, a referência do espaço de memória anterior se perde.
        carro1 = carro2;

=============================================================================

44 - Orientação Objetos - Métodos pt 01

--Atributos--
-SINTAXE: modificador de acesso + tipo da variável + identificador
-Exemplo1: public int idade;
-Exemplo2: professor.nome = "Kakashi";
-OBS: Usa-se o sinal de igual para dar o valor.

--Métodos--
-SINTAXE: modificador de acesso + retorno + nome do método + () + {}
-Parecido com os atributos mas com a funcionalidade diferente;
-Refere-se ao comportamento das classes;
-Eles retornam algo ou não retorna nada. (Diferente de saída)
-Exemplo1: public void somaDoisNumeros(){}
-Exemplo2: calculadora.somaDoisNumeros();
-OBS: Usa-se o ponto final + o nome do método seguido de parentêses

**Assim como os Atributos, os métodos são executados nos objetos.

=============================================================================

45 - Orientação Objetos - Métodos pt 02 - Parâmetros

--Parâmetros--
-SINTAXE: tipo de variável + identificador
(os tipos primitivos ou as de referência, até mesmo arrays)
-São variáveis locais.
-Exemplo: public void multiplicaDoisNumeros(int num1, int num2)

=============================================================================

46 - Orientação Objetos - Métodos pt 03 - Retorno pt 01

Método com retorno
REGRA: Também pode ser usado para métodos void.

public + tipo da variável primitiva ou reference + nome da variável {
return x;
}

=============================================================================

47 - Orientação Objetos - Métodos pt 04 - Retorno pt 02

1)Outra forma de usar o Return:
public double divideDoisNumeros02(double num1, double num2){
        if (num1 == 0 || num2 == 0) {
            return 0;
        } else
        return num1/num2;
    }

2)Outra forma:
public double divideDoisNumeros02(double num1, double num2){
         if (num2 != 0) {
         return num1/num2;
         }
         return 0;

3) Usando o return no método void:
public void imprimeDivisaoDoisNumeros(double num1, double num2) {
        if (num2 == 0) {
            System.out.println("Não existe divisão por zero.");
        }
        System.out.println(num1/num2);

OBS: Usar uma chamada de método dentro de um system.out.println em que o retorno é void (não existe), terá um erro de compilação.
O system.out.println precisa de um valor para imprimir no console.
Então, para executar o método, é preciso retirar o system.out.println

System.out.println(calculadora.imprimeDivisaoDoisNumeros(20,10));

calculadora.imprimeDivisaoDoisNumeros(20,10);

3.1)Usando o return:
public void imprimeDivisaoDoisNumeros(double num1, double num2) {
        if (num2 == 0) {
            System.out.println("Não existe divisão por zero.");
            return;
        }
            System.out.println(num1 / num2);

---------------
- Usando o if else
public void imprimeDivisaoDoisNumeros(double num1, double num2) {
        if (num2 == 0) {
            System.out.println("Não existe divisão por zero.");
        } else {
            System.out.println(num1 / num2);

=============================================================================

48 - Orientação Objetos - Métodos pt 05 - Parâmetros tipo primitivo

-Passagem de parâmetros do tipo primitivo:
Quando se passa valores do tipo primitivo para um método não estamos passando a referência daquele objeto em memória, estamos fazendo uma cópia.
*Então, passando variáveis do tipo primitivo, sempre envia-se uma cópia.
-A variável original nunca será alterada dentro do método.

=============================================================================

49 - Orientação Objetos - Métodos pt 06 - Parâmetros tipo referência

-Passagem de parâmetros do tipo referência:
Quando passamos parâmetros via referência estamos passando a própria referência dele.
Quando passamos objetos como argumento, na verdade estamos passando a referência aonde aquele objeto está guardado.
A referência original continua.

-Com 2 objetos, como melhorar o código sem a necessidade de repetição em que apenas a variável de referutilizando a coesão:
Criar uma variável através de uma classe específica.

=============================================================================

50 - Orientação Objetos - Métodos pt 07 - Parâmetros tipo referência pt 02

-Quando se altera algo dentro do objeto, essa alteração é mantida para as outras referências que ainda possuem ligação com esse objeto.
-Qualquer alteração feito dentro da classe vai afetar o objeto que esteja contido nela.
-OBS: A passagem de parâmetro via referência é perigosa, pois quando usamos tipos primitivos usa-se uma cópia (nunca altera-se o original),
mas passagem de parametros via referência, tudo o que for feito no objeto, afetará o objeto, independente do que fizermos dentro de outra classe ou dentro da classse originária (onde criou-se o objeto)
-As boas regras da programação diz que ao invés de alterar os dados que estão sendo passado para o objeto, é preciso retornar um novo objeto.

=============================================================================

51 - Orientação Objetos - Métodos pt 08 - Referência this

-Toda vez que executamos alguma coisa temos que chamar a variável de referência.
-Quem executa os dado em si é o objeto.
-Atribuir um valor: variavel de referencia.atributo = alguma coisa
-Estamos sempre executando dentro do método.

Método imprime
-Quando fica dentro do objeto, ao ser chamado, consehue acessar todos os valores que tem disponivel,
isso ajuda a não precisar criar uma variável de referência. Na prórpia variável de referência só chamaremos o atributo imprime.

THIS:
-Palavra reservada usada para se referir a algo que está dentro do próprio objeto.
-

A variável de referência é como um controle remoto, e os atributos são os botões desse controle.
O objeto é quem executa.

=============================================================================

52 - Orientação Objetos - Métodos pt 09 - Varargs

Varargs:
- Sintaxe que foi criada para deixar as coisas mais simples.
- Outra forma de representar os Arrays.
- A vantagem dele em comparação aos Arrays é a forma mais simples de passar vários elementos do mesmo tipo para um método.
Sintaxe: tipo + ... + nomedavariavel
public void somaVarArgs(int ... numeros)

-VarArgs precisa vir depois caso haja outro atributo.
public void somaVarArgs(double valor, double v2, int ... numeros)

=============================================================================

53 - Orientação Objetos - Métodos pt 10 - Exercise
-Exercício relacionado a Métodos, Classes, Objetos e tudo o que foi visto até agora:

CRIE UMA CLASSE FUNCIONÁRIO COM OS SEGUINTES ATRIBUTOS:

nome
idade
salario // 3 salários devem ser guardados

CRIE 2 MÉTODOS

1. PARA IMPRIMIR OS DADOS
2. PARA TIRAR A MÉDIA DOS SALÁRIOS E IMPRIMIR O RESULTADO


OBS: Dividir o problema e resolver cada parte.

=============================================================================

54 - Orientação Objetos - Modificador de acesso private, get e set pt 01

//
OBS: Para iniciar um objeto: Temos que criar uma variável de referência,
em seguida instanciar um objeto, e precisamos inicializar os atributos.
//

-Acoplamento: o quanto uma classe conhece da outra.
O quão uma classe está conectada com a outra.
-Para isso, temos os modificadores de acesso (public, private)
-Uma forma de garantir baixo acoplamento é utilizar modificadores de acesso privado.

--PRIVATE--
- Os atributos só poderão ser acessados pelos objetos.
- Pode-se criar o objeto, mas ao executar o método imprime, vai imprimir os valores padrões na criação de variáveis de classe.
- Como atribuir valores:
Quando se criar atributos privados, pode-se criar um método para acessá-los
REGRA DO JAVA:
SEMPRE QUE FOR CRIAR UM MÉTODO PARA INSERIR UM VALOR DENTRO DE UM ATRIBUTO INICIA-SE DIGITANDO A PALAVRA set.

-Como proteger ao usar o set:

OBS:
Alta Coesão é BOM
Baixo Acoplamento é BOM

--SET x GET--
set é para setar (precisa de um argumento do mesmo tipo da variável, não vai retornar nada)
get é para pegar (

=============================================================================

55 - Orientação Objetos - Modificador de acesso private, get e set pt 02

A variável de referência acessa tudo que é público. (set, get)
Exemplo:

private String nome;
private int idade;

setNome(String nome) // esse nome vai para o espaço de memória do private String nome
getNome() // retorna o que tem em memória no private String nome

------

Dentro do objeto, temos acesso a tudo dentro dele, incluindo os métodos.

=============================================================================

56 - Orientação Objetos - Modificador de acesso private, get e set pt 03

Importância de tomar cuidado ao criar um método get, set para um atributo:

*HACKS:
alt+insert = gera os getters e setters

Forma de bloquear o acesso a escrita e deixar somente a leitura
Remover o set (o que dá o valor ao atributo) e deixar somente o get (retorna o que temos em memória)

=============================================================================

57 - Orientação Objetos - Sobrecarga de métodos

Deixar a estrutura do set e get no final do código, pois em termos de importância,
são menores do que o método para impressão e os atributos.

- Sobrecarga de métodos: Ter um método com o mesmo nome,
porém o tipo ou a quantidade dos parâmetros são diferentes.
OBS: o modificador de acesso e o retorno não importam aqui. (public void)

- Criar métodos que peçam vários argumentos:
public void nomedometodo

Para evitar quebra de código, cria-se outro método com o mesmo nome.

PROBLEMA: Repetição de código.
SOLUÇÃO: chamar o primeiro método dentro do segundo método

REGRA DA SOBRECARGA:
-Ter o método com o mesmo nome só que a quantidade de parâmetro ou
o tipo dos parâmetros precisa se diferente.

=============================================================================

58 - Orientação Objetos - Construtores pt 01

- Construtores: Todas as vezes que criamos um objetos estamos construindo um objeto.
- Se não escrevermos um construtor na classe, o JAVA vai adicionar um no meio
da compilação (transformar o .java em .class)
- Precisa-se de um construtor para se dar origem ao um objeto.


1ª REGRA:
Construtor não tem nenhum tipo de retorno.
SINTAXE: modificador de acesso + nome da classe + () {}
EXEMPLO: public Anime(){}

--------------------------
OBS1: Construtor x Método:
Método: tem retorno (void)
public void Anime(){}
Construtor: não tem retorno
public Anime(){}
--------------------------

VANTAGEM DOS CONSTRUTORES:
- Força a seguir algumas regras.
- É executado antes de qualquer método contido na classe.
- Podemos usar o construtor para a inicialização de objetos na criação do mesmo.
- SOBRECARGA DE CONSTRUTORES: Criar objeto com todos os atributos e sem atributos
Criar outro construtor com o mesmo nome, obrigatoriamente, mas cria-se sem os parâmetros.

--------------------------
OBS2:
- É um inicializador dos objetos, responsável pela criação no momento
em que se pede determinados parâmetros é obrigatório passá-los,
a não ser que se tenha um construtor sobrecarregado.
--------------------------

=============================================================================

59 - Orientação Objetos - Construtores pt 02 - Sobrecarga

-Construtor é relacionado ao objeto.

-Como funciona a sobrecarga de construtores-

-Sintaxe: this.();
- Essa sintaxe só pode ser usada dentro de um construtor.
- this deve ser a primeira linha executável do corpo do construtor.

this(argumentos);

=============================================================================

60 - Orientação Objetos - Blocos de inicialização

-A inicialização dos objetos acontecem antes da construção da execução do construtor.
-Geralmente antes dos construtores e depois dos atributos, abre e fecha chaves.
-São instãncias, pois é executado todas as vezes que o objeto é criado, antes do construtor.

DIFERENÇA ENTRE BLOCO DE INICIALIZAÇÃO E O CONSTRUTOR:
-Bloco de inicialização é executado independente do construtor que for chamado;

=============================================================================

61 - Orientação Objetos - Modificador static

-Faz o atributo pertencer à classe e
todos os objetos derivados dessa classe (instâncias)
vão compartilhar o mesmo valor.

Propriedade que seja independente do objeto,
que afete a instância Carro em si e os objetos que serão criados.
Criar um modificador estático.

SINTAXE: Modificador de acesso + modificador estático
Exemplo: private static double velocidadeLimite;

Identificador que está relacionado a classe em si.

this se refere a instância do objeto.
Dentro do objeto teremos acesso aos atributos estáticos,
Exemplo: this.velocidadeLimite
mas não é aconselhável para evitar confusão. Acessar através da própria classe.
Exemplo: CArro.velocidadeLimite

=============================================================================

62 - Orientação Objetos - Métodos estáticos

Como criar um método estático:
Da mesma forma que se cria um atributo, pode-se começar com static public ou
public static.
EXEMPLO: static public void setVelocidadeLimite(double velocidadeLimite){}

OBS: Não é recomendado iniciar com STATIC. É convencionado que primeiro se tem o modificador
de acesso e depois o STATIC.
EXEMPLO: public static void setVelocidadeLimite(double velocidadeLimite){}

-Métodos GET e SET

- Além do this, não pode-se acessar nenhuma variável estática
dentro de métodos estáticos.
- Pq métodos estáticos não podem acessar atributos de instâncias:
Quando usa-se o STATIC existe a possibilidade de não existir um objeto em memória,
então não é possível pegar uma variável que só pode existir em memória.
-O contrário é possível, um objeto sempre é criado depois dos valores estáticos serem inicializados.
Sempre vai existir os estáticos depois de criar um atributo.

-RECOMENDAÇÃO DE UTILIZAÇÃO DE MÉTODOS ESTÁTICS E NÃO ESTÁTICOS:
Quando os métodos não acessam a variável (atributo da instância).

=============================================================================

63 - Orientação Objetos - Bloco de inicialização estático

Toda vez que criamos um objeto, estamos executando um bloco de inicialização.
Esse bloco de inicialização sempre será executado todas as vezes que um novo objeto for criado.

- Quando trabalhamos com atributos estáticos não usamos o this usamos o nome da própria classe.

- Quando se trabalha com blocos de inicialização estáticos, só precisamos adicionar
a palavra STATIC antes do bloco e inicialização.

- É executado apenas uma vez quando a classe é carregada pela JVM e isso acontece antes
de qualquer coisa, até mesmo antes de alocar espaço em memória pelo objeto.
Se houver uma ordem, eles aparecem na ordem de aparição.
Não podemos acessar atributos de instâncias dentro de métodos estáticos
justamente por ainda nem existir um objeto em memória quando o bloco é executado.

=============================================================================

64 - Orientação Objetos - Associação pt 01 - Arrays com Objetos

A associação em programação orientada a objetos é um conceito que descreve como classes
e objetos estão conectados e interagem entre si.
Em Java, uma forma comum de associação é através de arrays com objetos.

Resumindo:

Associação em Java:
Em Java, a associação é a relação entre duas classes,
onde uma classe usa ou é usada por outra.
Ela pode ser realizada de diversas formas, incluindo composição,
agregação e herança.

Arrays com Objetos:
Arrays em Java são estruturas que armazenam múltiplos valores do mesmo
tipo em uma única variável.
Arrays podem conter objetos como elementos, permitindo armazenar
várias instâncias de uma classe em uma estrutura de dados.
Isso é útil quando você precisa lidar com coleções de
objetos do mesmo tipo, como uma lista de alunos em uma turma,
uma coleção de produtos em um estoque, etc.
Para criar um array de objetos em Java, você declara o array do
tipo da classe do objeto e instancia cada objeto individualmente.

=============================================================================

65 - Orientação Objetos - Associação pt 02 - Associação unidirecional um para muitos

Jogador 1 --  1 Personagem
Time 1 -- N  Jogador
Jogador N -- 1  Time
Estudante N -- N  Curso

Associação: Criar relacionamento entre classes e objetos no JAVA

=============================================================================

66 - Orientação Objetos - Associação pt 03 - Associação unidirecional muitos para um

- A associação unidirecional muitos para um é útil para modelar relacionamentos onde uma entidade
pode ter várias instâncias de outra entidade, mas cada instância
da segunda entidade só pode estar relacionada a uma instância da primeira.

-Conceito:
Uma associação unidirecional muitos para um define um relacionamento onde uma instância de uma classe (muitos) pode estar relacionada a no máximo uma instância de outra classe (um).
Na analogia, uma escola pode ter vários professores, mas um professor só pode pertencer a uma escola.

**Exemplo:
Classe Escola:
Atributos: nome
Método: imprimir() - exibe o nome da escola e seus professores
Classe Professor:
Atributos: nome, escola (associação com a classe Escola)
Método: imprimir() - exibe o nome do professor e sua escola

-Implementação:
A associação é unidirecional da escola para o professor.
A escola possui uma lista de professores.
O professor possui uma referência para a escola a qual pertence.
Métodos imprimir() em ambas as classes exibem as informações relevantes da associação.

-Criação de Objetos:
Uma escola pode ser criada sem professores.
Um professor precisa ser criado com uma escola associada.
A escola pode adicionar professores à sua lista após sua criação.

-Modificação da Associação:
A escola pode trocar de professor.
Um professor pode ser desassociado da escola.

-Observações:
A ordem de criação dos objetos não importa, mas é mais intuitivo criar a escola primeiro.
É possível sobrecarregar o construtor da escola para criar uma instância com professores pré-definidos.
O acionamento de métodos em objetos associados funciona da mesma forma que em associações unidirecionais um para um.

=============================================================================

67 - Orientação Objetos - Associação pt 04 - Associação bidirecional

O que é Associação Bidirecional?

Na OO, a associação permite que objetos se relacionem entre si.
A associação bidirecional, em particular, significa que dois objetos
possuem referências um ao outro.
Isso permite que ambos os objetos acessem e modifiquem os atributos do outro.

Exemplo: Time e Jogador
Um time pode ter vários jogadores, e cada jogador pertence
a um único time. Essa relação pode ser representada por meio de
associação bidirecional.

Criando Classes e Atributos
A classe Time possui um atributo jogadores do tipo List<Jogador>,
que armazena os jogadores do time.
Já a classe Jogador possui um atributo time do tipo Time,
que referencia o time ao qual o jogador pertence.

Métodos para Adicionar e Remover Jogadores
São implementados métodos nas classes Time e Jogador para
adicionar e remover jogadores.
O método addJogador na classe Time adiciona um jogador à lista
de jogadores do time. Já o método removerJogador
remove um jogador da lista. Na classe Jogador, o método setTime define
o time ao qual o jogador pertence.

Imprimindo Informações
Criação de um método imprimir em ambas as classes para exibir as
informações dos objetos. O método imprimir na classe Time exibe o
nome do time e seus jogadores, enquanto o método imprimir na
classe Jogador exibe o nome do jogador e o time ao qual ele pertence.

Pontos Importantes:
A associação bidirecional permite que objetos se relacionem e
modifiquem os atributos uns dos outros.
É importante garantir a consistência dos dados ao utilizar
associação bidirecional.
É crucial entender como os objetos se comunicam
na memória para trabalhar com associação bidirecional.

=============================================================================

68 - Orientação Objetos - Leitura de dados pelo console

**Pontos chave**

--Importando a classe Scanner:
Para ler dados do teclado, é necessário importar a
classe Scanner do pacote java.util.
Essa classe é a chave para desbloquear
o poder da leitura de dados do teclado.

--Criando um objeto Scanner:
Para interagir com o teclado, um objeto Scanner é criado
utilizando o construtor Scanner(System.in),
passando o objeto System.in como argumento.
Ele representa a entrada padrão do sistema,
pronto para receber seus comandos.

--Lendo Diversos Tipos de Dados:
A leitura de dados é feita usando o método next(),
que retorna o próximo valor digitado pelo usuário como uma string.
Para ler tipos de dados específicos, como int ou double,
existem métodos específicos como nextInt() e nextDouble().
--Exemplo de uso:
Scanner scanner = new Scanner(System.in);

System.out.print("Digite seu nome: ");
String nome = scanner.nextLine();

System.out.print("Digite sua idade: ");
int idade = scanner.nextInt();

System.out.print("Digite seu sexo (M/F): ");
String sexo = scanner.nextLine();

System.out.println("Nome: " + nome);
System.out.println("Idade: " + idade);
System.out.println("Sexo: " + sexo);


--Validação de Dados: Garantindo a Qualidade da Entrada
A validação de dados é crucial para garantir que os valores
digitados pelo usuário estejam válidos e dentro do formato
esperado pelo programa. Isso evita erros e falhas de execução,
tornando seu programa mais robusto.
Exemplo de Validação de Tipo:

  Scanner scanner = new Scanner(System.in);

  System.out.print("Digite um número inteiro: ");
  while (!scanner.hasNextInt()) {
    System.out.print("Valor inválido. Digite um número inteiro: ");
    scanner.next();
  }
  int numero = scanner.nextInt();


--Tratamento de Erros: Lidando com Imprevistos
O tratamento de erros é essencial para lidar com situações
em que a validação de dados falha.
Seu objetivo é evitar que o programa falhe completamente e
que o usuário seja notificado de forma amigável.

Exemplo de Tratamento de Erros:

Scanner scanner = new Scanner(System.in);

System.out.print("Digite um número inteiro: ");
try {
  int numero = scanner.nextInt();
} catch (InputMismatchException e) {
  System.out.println("Valor inválido. Digite um número inteiro.");
  scanner.next(); // Limpa o buffer do scanner
}
Use o código com cuidado.
content_copy


--Dicas para Validação e Tratamento de Erros Eficazes:
1-Valide todos os dados digitados pelo usuário.
2-Utilize mensagens de erro claras e amigáveis.
3-Implemente um tratamento de erros robusto.
4-Registre os erros em logs para facilitar a análise e depuração.
5-Teste o programa com diferentes tipos de dados.


--Vantagens e desvantagens:
A leitura do teclado é útil para testes e interação básica com o usuário,
mas pode ser impraticável para grandes volumes de dados.

--Alternativas:
Para grandes volumes de dados, é recomendável usar outras formas
de entrada, como arquivos ou interfaces gráficas.

=============================================================================

69 - Orientação Objetos - Exercício leitura de dados do teclado

=============================================================================

70 - Orientação Objetos - Associação pt 05 - Exercício Associação

-Crie um sistema que gerencie seminários.
-O sistema deverá cadastrar seminários, estudantes, professores
e local onde será realizado.

1 aluno poderá estar em apenas 1 seminário;
1 seminário poderá ter nenhum ou vários alunos;
1 professor poderá ministrar vários seminários;
1 seminário deve ter um local.

-Campos básicos (excluindo relacionamento):
seminário: título
aluno: nome e idade;
professor: nome, especialidade
local: endereço

=============================================================================

71 - Orientação Objetos - Herança pt 01

-O que é Herança?
Herança é um mecanismo de programação que permite que uma
classe (chamada classe derivada) herde atributos e métodos de outra
classe (chamada classe base).
Isso significa que a classe derivada pode usar os mesmos
atributos e métodos da classe base, além de ter seus próprios
atributos e métodos específicos.

-Benefícios da Herança:
*Reutilização de código: A herança permite que você reutilize
código existente, evitando duplicação e tornando o código mais organizado.
*Hierarquia de classes: A herança permite criar uma hierarquia
de classes que reflete as relações entre os objetos no mundo real.
*Especialização: A herança permite que você crie classes mais
específicas que herdam funcionalidades de classes mais genéricas.

**Exemplo de Herança:
Classes Pessoa e Funcionário para demonstrar o conceito de herança.
A classe Pessoa possui atributos como nome, CPF e endereço,
enquanto a classe Funcionário herda esses atributos da classe Pessoa e
possui um atributo adicional chamado salário.

-Implementação da Herança em Java:
Na linguagem Java, a herança é implementada utilizando a
palavra-chave extends.
Por exemplo, a classe Funcionário herda da classe Pessoa da
seguinte forma:

Java
class Funcionario extends Pessoa {
  // Atributos específicos da classe Funcionário
  private double salario;

  // Métodos específicos da classe Funcionário
  public void imprimirSalario() {
    System.out.println("Salário: " + this.salario);
  }
}


-Considerações sobre o Uso da Herança:
A herança deve ser utilizada com cuidado,
pois pode levar a um acoplamento forte entre as classes,
dificultando a manutenção do código.
Em geral, a herança é recomendada quando existe uma relação
de "é um" entre as classes, ou seja, quando uma classe é um
tipo específico de outra classe.

=============================================================================

72 - Orientação Objetos - Herança pt 02 - Super

-O que é herança?
Herança é um mecanismo em Orientação a Objetos que permite que uma
classe (filha) herde atributos e métodos de outra classe (pai).
Isso significa que a classe filha pode reutilizar o código da classe pai,
evitando duplicação e promovendo organização.

Exemplos:
Classe Pessoa: Possui atributos como nome, CPF e endereço.
Classe Funcionário: É uma classe filha da classe Pessoa,
herdando seus atributos e métodos. Além disso, possui atributos
específicos como salário e desconto.

-Método super:
O método super permite que a classe filha acesse e utilize métodos da
classe pai.

-Sobreescrita de métodos:
A sobreescrita de métodos permite que a classe filha redefina
o comportamento de um método herdado da classe pai.

-Exemplo de sobreescrita:
Python
class Pessoa:
  def __init__(self, nome, cpf, endereco):
    self.nome = nome
    self.cpf = cpf
    self.endereco = endereco

  def imprimir(self):
    print(f"Nome: {self.nome}")
    print(f"CPF: {self.cpf}")
    print(f"Endereço: {self.endereco}")

class Funcionario(Pessoa):
  def __init__(self, nome, cpf, endereco, salario, desconto):
    super().__init__(nome, cpf, endereco)
    self.salario = salario
    self.desconto = desconto

  def imprimir(self):
    super().imprimir()
    print(f"Salário: {self.salario}")
    print(f"Desconto: {self.desconto}")

funcionario = Funcionario("Cássia Eller", "12345678900", "Rua X, 123", 3000, 100)
funcionario.imprimir()

Resultado:

Nome: Cássia Eller
CPF: 12345678900
Endereço: Rua X, 123
Salário: 3000
Desconto: 100
Conclusão:

=============================================================================

73 - Orientação Objetos - Herança pt 03 - protected

Relembrando a Herança:
A herança permite que uma classe (filha) herde atributos e
métodos de outra classe (pai).
Isso significa que a classe filha pode utilizar os
atributos e métodos da classe pai, além de ter seus próprios
atributos e métodos específicos.

Modificador de Acesso protected:
Subclasse acessa atributo como
se fosse público em qualquer lugar.
Se não for subclasse, somente se tiver dentro do mesmo pacote.
O modificador de acesso protected define que um membro
da classe (atributo ou método) é acessível apenas
dentro da própria classe, nas classes filhas e nas
classes do mesmo pacote.
Isso significa que o membro
protected não é acessível em classes de outros pacotes.

-Vantagens do protected:
*Encapsulamento: O protected ajuda a encapsular os membros da classe, escondendo-os de classes externas, mas permitindo que eles sejam acessados ​​por classes filhas e classes do mesmo pacote.
*Reutilização de código: O protected facilita a reutilização de código, pois permite que as classes filhas utilizem os membros protected da classe pai sem precisar reimplementá-los.
*Organização do código: O protected promove a organização do código, definindo diferentes níveis de visibilidade para os membros da classe.

-Exemplo de Uso do protected:
Classes Pessoa, Funcionario e Gerente para demonstrar o
uso do modificador de acesso protected.
A classe Pessoa possui atributos nome e endereco
como protected. A classe Funcionario herda esses
atributos e pode acessá-los diretamente.
A classe Gerente, que é uma classe filha de Funcionario,
também pode acessar os atributos protected da classe Pessoa.

Conclusão:
O protected pode ser utilizado para encapsular código,
promover reutilização e organizar o código de forma
eficiente.


=============================================================================



=============================================================================



=============================================================================



=============================================================================

